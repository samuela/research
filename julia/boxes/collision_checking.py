# -*- coding: utf-8 -*-
"""collision checking.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uV4nIKd999VREcABKkDWRcFoXxGDyJ7F
"""

import matplotlib.pyplot as plt
import random

def oo_and(l, r):
  if isinstance(l, bool) and isinstance(r, bool):
    return l and r
  if isinstance(l, BoolSet) and isinstance(r, BoolSet):
    return BoolSet(([True] if l.canTrue and r.canTrue else []) + ([False] if l.canFalse or r.canFalse else []))
  print(type(l), type(r))
  raise

def oo_or(l, r):
  if isinstance(l, BoolSet) and isinstance(r, BoolSet):
    return BoolSet(([True] if l.canTrue or r.canTrue else []) + ([False] if l.canFalse and r.canFalse else []))
  if isinstance(l, BoolSet) and isinstance(r, bool):
    return oo_or(l, BoolSet([r]))
  print(type(l), type(r))
  raise

def oo_square(x):
  if isinstance(x, float):
    return x * x
  if isinstance(x, Interval):
    approx = x * x
    # return approx # XXX
    return Interval((max(0, approx.min), approx.max))
  print(type(x))
  raise

class BoolSet:
  def __init__(self, bools):
    self.canTrue = any(bools)
    self.canFalse = any([not b for b in bools])
  def __repr__(self):
    return "BoolSet{" + str(([False] if self.canFalse else []) + ([True] if self.canTrue else [])) + "}"
  def __eq__(self, other):
    if not isinstance(other, BoolSet):
      other = BoolSet([other])
    return self.canTrue == other.canTrue and self.canFalse == self.canFalse

class Interval:
  def __init__(self, xs):
    self.min = min(xs)
    self.max = max(xs)
  def __repr__(self):
    return "[" + str(self.min) + ", " + str(self.max) + "]"
  def __ge__(self, other):
    if not isinstance(other, Interval):
      other = Interval([other])
    return BoolSet(([True] if other.min <= self.max else []) + ([False] if not (other.max <= self.min) else []))
  def __le__(self, other):
    if not isinstance(other, Interval):
      other = Interval([other])
    return BoolSet(([True] if self.min <= other.max else []) + ([False] if not (self.max <= other.min) else []))
  def __mul__(self, other):
    if not isinstance(other, Interval):
      other = Interval([other])
    return Interval([self.min * other.min, self.min * other.max, self.max * other.min, self.max * other.max])
  def __add__(self, other):
    if not isinstance(other, Interval):
      other = Interval([other])
    return Interval([self.min + other.min, self.max + other.max])
  def __contains__(self, x):
    return self.min <= x <= self.max
  def width(self):
    return self.max - self.min

def is_free(x, y):
  return oo_and(-2 <= x <= 2, oo_and(-2 <= y <= 2, oo_square(x) + oo_square(y) >= 1))

is_free(1.5, 1.5)

def draw_world(boxes):
  figure, axes = plt.subplots()
  circle = plt.Circle((0.0, 0.0), 1, color = "dimgrey")

  axes.set_aspect(1)
  axes.set_xlim(-2, 2)
  axes.set_ylim(-2, 2)
  axes.add_artist(circle)

  for (x_interval, y_interval) in boxes:
    box = plt.Rectangle((x_interval.min, y_interval.min), x_interval.width(), y_interval.width(), alpha = 0.2)
    axes.add_artist(box)

  plt.title(f"World, {len(boxes)} boxes")
  plt.show()

draw_world([(Interval([0, 1]), Interval([0, 1]))])

assert oo_or(BoolSet([True, False]), BoolSet([False, True])) == BoolSet([False, True])
assert oo_or(BoolSet([True]), BoolSet([False, True])) == True
assert oo_or(BoolSet([True, False]), BoolSet([True])) == True
assert oo_or(BoolSet([True, False]), True) == True

x = Interval((1.9, -1.9))
y = Interval((1.7, 1.3))
is_free(x, y)

def getBox(x, y):
  x = Interval([x])
  y = Interval([y])
  if is_free(x, y).canFalse:
    return None
  x_last = x
  y_last = y
  while not is_free(x, y).canFalse:
    x_last = x
    y_last = y
    x = x + Interval([-0.01, 0.01])
    y = y + Interval([-0.01, 0.01])
  return (x_last, y_last)
print(getBox(-1.5, 0.1))

random.seed(123)

boxes = []
while len(boxes) < 100:
  x = random.uniform(-2, 2)
  y = random.uniform(-2, 2)
  if any((x in bx) and (y in by) for (bx, by) in boxes):
    # print("xy already covered in boxes")
    continue
  if not is_free(x, y):
    # print("xy in collision")
    continue
  boxes.append(getBox(x, y))
  draw_world(boxes)

def plan(boxes, start, goal)
